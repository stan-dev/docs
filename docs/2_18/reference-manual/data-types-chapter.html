<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Stan Reference Manual</title>
  <meta name="description" content="Stan reference manual specifying the syntax and semantics of the Stan programming language.">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="Stan Reference Manual" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="img/logo_tm.png" />
  <meta property="og:description" content="Stan reference manual specifying the syntax and semantics of the Stan programming language." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Stan Reference Manual" />
  
  <meta name="twitter:description" content="Stan reference manual specifying the syntax and semantics of the Stan programming language." />
  <meta name="twitter:image" content="img/logo_tm.png" />

<meta name="author" content="Stan Development Team">



  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="whitespace.html">
<link rel="next" href="expressions.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />










<link rel="stylesheet" href="../stan-manual.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li style="font-size:110%; font-weight:400; font-family: Verdana, Helvetica, sans; line-height:1.4; margin: 0.5em 0 0 1em">Stan Reference Manual</li>

<li class="divider"></li>
<li><a href="index.html#overview"><i style="font-size: 110%; padding:1.5em 0 0 0; color:#990017;">Overview</i></a></li>
<li><a href="language.html#language"><i style="font-size: 110%; color:#990017;">Language</i></a></li>
<li class="chapter" data-level="1" data-path="character-encoding.html"><a href="character-encoding.html"><i class="fa fa-check"></i><b>1</b> Character Encoding</a></li>
<li class="chapter" data-level="2" data-path="includes-section.html"><a href="includes-section.html"><i class="fa fa-check"></i><b>2</b> Includes</a></li>
<li class="chapter" data-level="3" data-path="comments-section.html"><a href="comments-section.html"><i class="fa fa-check"></i><b>3</b> Comments</a></li>
<li class="chapter" data-level="4" data-path="whitespace.html"><a href="whitespace.html"><i class="fa fa-check"></i><b>4</b> Whitespace</a></li>
<li class="chapter" data-level="5" data-path="data-types-chapter.html"><a href="data-types-chapter.html"><i class="fa fa-check"></i><b>5</b> Data Types and Declarations</a></li>
<li class="chapter" data-level="6" data-path="expressions.html"><a href="expressions.html"><i class="fa fa-check"></i><b>6</b> Expressions</a></li>
<li class="chapter" data-level="7" data-path="statements.html"><a href="statements.html"><i class="fa fa-check"></i><b>7</b> Statements</a></li>
<li class="chapter" data-level="8" data-path="blocks-chapter.html"><a href="blocks-chapter.html"><i class="fa fa-check"></i><b>8</b> Program Blocks</a></li>
<li class="chapter" data-level="9" data-path="functions-chapter.html"><a href="functions-chapter.html"><i class="fa fa-check"></i><b>9</b> User-Defined Functions</a></li>
<li class="chapter" data-level="10" data-path="variable-transforms-chapter.html"><a href="variable-transforms-chapter.html"><i class="fa fa-check"></i><b>10</b> Constraint Transforms</a></li>
<li class="chapter" data-level="11" data-path="language-syntax.html"><a href="language-syntax.html"><i class="fa fa-check"></i><b>11</b> Language Syntax</a></li>
<li class="chapter" data-level="12" data-path="program-execution.html"><a href="program-execution.html"><i class="fa fa-check"></i><b>12</b> Program Execution</a></li>
<li class="chapter" data-level="13" data-path="deprecated-features-appendix.html"><a href="deprecated-features-appendix.html"><i class="fa fa-check"></i><b>13</b> Deprecated Features</a></li>
<li><a href="algorithms.html#algorithms"><i style="font-size: 110%; color:#990017;">Algorithms</i></a></li>
<li class="chapter" data-level="14" data-path="hmc-chapter.html"><a href="hmc-chapter.html"><i class="fa fa-check"></i><b>14</b> MCMC Sampling</a></li>
<li class="chapter" data-level="15" data-path="analysis-chapter.html"><a href="analysis-chapter.html"><i class="fa fa-check"></i><b>15</b> Posterior Analysis</a></li>
<li class="chapter" data-level="16" data-path="optimization-algorithms-chapter.html"><a href="optimization-algorithms-chapter.html"><i class="fa fa-check"></i><b>16</b> Optimization</a></li>
<li class="chapter" data-level="17" data-path="vi-algorithms-chapter.html"><a href="vi-algorithms-chapter.html"><i class="fa fa-check"></i><b>17</b> Variational Inference</a></li>
<li class="chapter" data-level="18" data-path="diagnostic-algorithms-chapter.html"><a href="diagnostic-algorithms-chapter.html"><i class="fa fa-check"></i><b>18</b> Diagnostic Mode</a></li>
<li><a href="usage.html#usage"><i style="font-size: 110%; color:#990017;">Usage</i></a></li>
<li class="chapter" data-level="19" data-path="reproducibility-chapter.html"><a href="reproducibility-chapter.html"><i class="fa fa-check"></i><b>19</b> Reproducibility</a></li>
<li class="chapter" data-level="20" data-path="licensing-appendix.html"><a href="licensing-appendix.html"><i class="fa fa-check"></i><b>20</b> Licenses and Dependencies</a></li>
<li><a href="references.html#references"><i style="font-size: 110%; color:#990017;">References</i></a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Stan Reference Manual</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="data-types.chapter" class="section level1">
<h1><span class="header-section-number">5</span> Data Types and Declarations</h1>
<p>This chapter covers the data types for expressions in Stan. Every
variable used in a Stan program must have a declared data type. Only
values of that type will be assignable to the variable (except for
temporary states of transformed data and transformed parameter
values). This follows the convention of programming languages like
C++, not the conventions of scripting languages like Python or
statistical languages such as R or BUGS.</p>
<p>The motivation for strong, static typing is threefold.</p>
<ol style="list-style-type: decimal">
<li>Strong typing forces the programmer’s intent to be declared with
the variable, making programs easier to comprehend and hence easier
to debug and maintain.</li>
<li>Strong typing allows programming errors relative to the declared
intent to be caught sooner (at compile time) rather than later (at
run time). The Stan compiler (called through an interface such as
CmdStan, RStan, or PyStan) will flag any type errors and indicate
the offending expressions quickly when the program is compiled.</li>
<li>Constrained types will catch runtime data, initialization, and
intermediate value errors as soon as they occur rather than allowing
them to propagate and potentially pollute final results.</li>
</ol>
<p>Strong typing disallows assigning the same variable to objects of
different types at different points in the program or in different
invocations of the program.</p>
<div id="overview-of-data-types" class="section level2">
<h2><span class="header-section-number">5.1</span> Overview of Data Types</h2>
<p>Arguments for built-in and user-defined functions and local variables
are required to be basic data types, meaning an unconstrained
primitive, vector, or matrix type or an array of such.</p>
<p>Passing arguments to functions in Stan works just like assignment to
basic types. Stan functions are only specified for the basic data
types of their arguments, including array dimensionality, but not for
sizes or constraints. Of course, functions often check constraints as
part of their behavior.</p>
<div id="primitive-types" class="section level3 unnumbered">
<h3>Primitive Types</h3>
<p>Stan provides two primitive data types, <code>real</code> for continuous
values and <code>int</code> for integer values.</p>
</div>
<div id="vector-and-matrix-types" class="section level3 unnumbered">
<h3>Vector and Matrix Types</h3>
<p>Stan provides three matrix-based data types, <code>vector</code> for column
vectors, <code>row_vector</code> for row vectors, and <code>matrix</code> for
matrices.</p>
</div>
<div id="array-types" class="section level3 unnumbered">
<h3>Array Types</h3>
<p>Any type (including the constrained types discussed in the next
section) can be made into an array type by declaring array arguments.
For example,</p>
<pre class="stan"><code>real x[10];
matrix[3, 3] m[6, 7];</code></pre>
<p>declares <code>x</code> to be a one-dimensional array of size 10 containing
real values, and declares <code>m</code> to be a two-dimensional array of
size <span class="math inline">\(6 \times 7\)</span> containing values that are <span class="math inline">\(3 \times 3\)</span> matrices.</p>
</div>
<div id="constrained-data-types" class="section level3 unnumbered">
<h3>Constrained Data Types</h3>
<p>Declarations of variables other than local variables may be provided
with constraints. These constraints are not part of the underlying
data type for a variable, but determine error checking in the
transformed data, transformed parameter, and generated quantities
block, and the transform from unconstrained to constrained space in
the parameters block.</p>
<p>All of the basic data types may be given lower and upper bounds using
syntax such as</p>
<pre class="stan"><code>int&lt;lower = 1&gt; N;
real&lt;upper = 0&gt; log_p;
vector&lt;lower = -1, upper = 1&gt;[3] rho;</code></pre>
<p>There are also special data types for structured vectors and
matrices. There are four constrained vector data types, <code>simplex</code>
for unit simplexes, <code>unit_vector</code> for unit-length vectors,
<code>ordered</code> for ordered vectors of scalars and
<code>positive_ordered</code> for vectors of positive ordered
scalars. There are specialized matrix data types <code>corr_matrix</code>
and <code>cov_matrix</code> for correlation matrices (symmetric, positive
definite, unit diagonal) and covariance matrices (symmetric, positive
definite). The type <code>cholesky_factor_cov</code> is for Cholesky
factors of covariance matrices (lower triangular, positive diagonal,
product with own transpose is a covariance matrix). The type
<code>cholesky_factor_corr</code> is for Cholesky factors of correlation
matrices (lower triangular, positive diagonal, unit-length rows).</p>
<p>Constraints provide error checking for variables defined in the
<code>data</code>, <code>transformed data</code>, <code>transformed parameters</code>,
and <code>generated quantities</code> blocks. Constraints are critical for
variables declared in the <code>parameters</code> block, where they
determine the transformation from constrained variables (those
satisfying the declared constraint) to unconstrained variables (those
ranging over all of <span class="math inline">\(\mathbb{R}^n\)</span>).</p>
<p>It is worth calling out the most important aspect of constrained data
types:</p>
<div style="margin:0 2em 0 2em">
<p><em>The model must have support (non-zero density, equivalently finite log density) at parameter values that satisfy the declared constraints.</em></p>
</div>
<p>If this condition is violated with parameter values that satisfy
declared constraints but do not have finite log density, then the
samplers and optimizers may have any of a number of pathologies
including just getting stuck, failure to initialize, excessive
Metropolis rejection, or biased draws due to inability to explore
the tails of the distribution.</p>
</div>
</div>
<div id="numerical-data-types.section" class="section level2">
<h2><span class="header-section-number">5.2</span> Primitive Numerical Data Types</h2>
<p>Unfortunately, the lovely mathematical abstraction of integers and
real numbers is only partially supported by finite-precision computer
arithmetic.</p>
<div id="integers" class="section level3 unnumbered">
<h3>Integers</h3>
<p>Stan uses 32-bit (4-byte) integers for all of its integer
representations. The maximum value that can be represented
as an integer is <span class="math inline">\(2^{31}-1\)</span>; the minimum value is <span class="math inline">\(-(2^{31})\)</span>.</p>
<p>When integers overflow, their values wrap. Thus it is up to the Stan
programmer to make sure the integer values in their programs stay in
range. In particular, every intermediate expression must have an
integer value that is in range.</p>
<p>Integer arithmetic works in the expected way for addition,
subtraction, and multiplication, but rounds the result of division
(see <a href="#int-arithmetic.section">section</a> for more information).</p>
</div>
<div id="reals" class="section level3 unnumbered">
<h3>Reals</h3>
<p>Stan uses 64-bit (8-byte) floating point representations of real
numbers. Stan roughly<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>
follows the IEEE 754 standard for floating-point computation.
The range of a 64-bit number is roughly <span class="math inline">\(\pm 2^{1022}\)</span>, which is
slightly larger than <span class="math inline">\(\pm 10^{307}\)</span>. It is a good idea to stay well
away from such extreme values in Stan models as they are prone to
cause overflow.</p>
<p>64-bit floating point representations have roughly 15 decimal digits
of accuracy. But when they are combined, the result often has less
accuracy. In some cases, the difference in accuracy between two
operands and their result is large.</p>
<p>There are three special real values used to represent (1) not-a-number
value for error conditions, (2) positive infinity for overflow, and
(3) negative infinity for overflow. The behavior of these special
numbers follows standard IEEE 754 behavior.</p>
<div id="not-a-number" class="section level4 unnumbered">
<h4>Not-a-number</h4>
<p>The not-a-number value propagates. If an argument to a real-valued
function is not-a-number, it either rejects (an exception in the
underlying C++) or returns not-a-number itself. For boolean-valued
comparison operators, if one of the arguments is not-a-number, the
return value is always zero (i.e., false).</p>
</div>
<div id="infinite-values" class="section level4 unnumbered">
<h4>Infinite values</h4>
<p>Positive infinity is greater than all numbers other than itself and
not-a-number; negative infinity is similarly smaller. Adding an
infinite value to a finite value returns the infinite value. Dividing
a finite number by an infinite value returns zero; dividing an
infinite number by a finite number returns the infinite number of
appropriate sign. Dividing a finite number by zero returns positive
infinity. Dividing two infinite numbers produces a not-a-number value
as does subtracting two infinite numbers. Some functions are
sensitive to infinite values; for example, the exponential function
returns zero if given negative infinity and positive infinity if given
positive infinity. Often the gradients will break down when values
are infinite, making these boundary conditions less useful than they
may appear at first.</p>
</div>
</div>
<div id="promoting-integers-to-reals" class="section level3 unnumbered">
<h3>Promoting Integers to Reals</h3>
<p>Stan automatically promotes integer values to real values if
necessary, but does not automatically demote real values to integers.
For very large integers, this will cause a rounding error to fewer
significant digits in the floating point representation than in the
integer representation.</p>
<p>Unlike in C++, real values are never demoted to integers. Therefore,
real values may only be assigned to real variables. Integer values
may be assigned to either integer variables or real variables.
Internally, the integer representation is cast to a floating-point
representation. This operation is not without overhead and should
thus be avoided where possible.</p>
</div>
</div>
<div id="univariate-data-types-and-variable-declarations" class="section level2">
<h2><span class="header-section-number">5.3</span> Univariate Data Types and Variable Declarations</h2>
<p>All variables used in a Stan program must have an explicitly declared
data type. The form of a declaration includes the type and the name
of a variable. This section covers univariate types, the next section
vector and matrix types, and the following section array types.</p>
<div id="unconstrained-integer" class="section level3 unnumbered">
<h3>Unconstrained Integer</h3>
<p>Unconstrained integers are declared using the <code>int</code> keyword.
For example, the variable <code>N</code> is declared to be an integer as follows.</p>
<pre class="stan"><code>int N;</code></pre>
</div>
<div id="constrained-integer" class="section level3 unnumbered">
<h3>Constrained Integer</h3>
<p>Integer data types may be constrained to allow values only in a
specified interval by providing a lower bound, an upper bound, or
both. For instance, to declare <code>N</code> to be a positive integer, use
the following.</p>
<pre class="stan"><code>int&lt;lower=1&gt; N;</code></pre>
<p>This illustrates that the bounds are inclusive for integers.</p>
<p>To declare an integer variable <code>cond</code> to take only binary values,
that is zero or one, a lower and upper bound must be provided, as in
the following example.</p>
<pre class="stan"><code>int&lt;lower=0,upper=1&gt; cond;</code></pre>
</div>
<div id="unconstrained-real" class="section level3 unnumbered">
<h3>Unconstrained Real</h3>
<p>Unconstrained real variables are declared using the keyword
<code>real</code>, The following example declares <code>theta</code> to be an
unconstrained continuous value.</p>
<pre class="stan"><code>real theta;</code></pre>
</div>
<div id="constrained-real" class="section level3 unnumbered">
<h3>Constrained Real</h3>
<p>Real variables may be bounded using the same syntax as integers. In
theory (that is, with arbitrary-precision arithmetic), the bounds on
real values would be exclusive. Unfortunately, finite-precision
arithmetic rounding errors will often lead to values on the
boundaries, so they are allowed in Stan.</p>
<p>The variable <code>sigma</code> may be declared to be non-negative as follows.</p>
<pre class="stan"><code>real&lt;lower=0&gt; sigma;</code></pre>
<p>The following declares the variable <code>x</code> to be less than or equal
to <span class="math inline">\(-1\)</span>.</p>
<pre class="stan"><code>real&lt;upper=-1&gt; x;</code></pre>
<p>To ensure <code>rho</code> takes on values between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span>, use the
following declaration.</p>
<pre class="stan"><code>real&lt;lower=-1,upper=1&gt; rho;</code></pre>
<div id="infinite-constraints" class="section level4 unnumbered">
<h4>Infinite Constraints</h4>
<p>Lower bounds that are negative infinity or upper bounds that are
positive infinity are ignored. Stan provides constants
<code>positive_infinity()</code> and <code>negative_infinity()</code> which may
be used for this purpose, or they may be read as data in the dump
format.</p>
</div>
</div>
<div id="affinely-transformed-real" class="section level3 unnumbered">
<h3>Affinely Transformed Real</h3>
<p>Real variables may be declared on a space that has been transformed using an
affine transformation <span class="math inline">\(x\mapsto \mu + \sigma * x\)</span> with location <span class="math inline">\(\mu\)</span> and
(positive) scale <span class="math inline">\(\sigma\)</span>, using a syntax similar to
that for bounds.
While these transforms do not change the asymptotic sampling behaviour of
the resulting Stan program (in a sense, the model the program implements),
they can be useful for making the sampling process
more efficient by transforming the geometry of the problem to a more natural
scale and to a more natural location for the sampling process,
for instance by fascilitating a non-centered parameterisation.
While these affine transformation declarations do not impose a hard constraint
on variables, they behave like the bounds constraints in many ways and could
perhaps be viewed as acting as a sort of soft constraint.</p>
<p>The variable <code>x</code> may be declared to have location <span class="math inline">\(1\)</span> as follows.</p>
<pre class="stan"><code>real&lt;location=1&gt; x;</code></pre>
<p>Similarly, it can be declared to have scale <span class="math inline">\(2\)</span> as follows.</p>
<pre class="stan"><code>real&lt;scale=2&gt; x;</code></pre>
<p>Finally, we can combine both declarations to declare a variable with location
<span class="math inline">\(1\)</span> and scale <span class="math inline">\(2\)</span>.</p>
<pre class="stan"><code>real&lt;location=1,scale=2&gt; x;</code></pre>
<p>As an example, we can give <code>x</code> a normal distribution with non-centered
parameterization as follows.</p>
<pre class="stan"><code>parameters {
  real&lt;location=mu,scale=sigma&gt; x;
}
model {
  x ~ normal(mu, sigma);
}</code></pre>
<p>Recall that the centered parameterization is achieved with the code</p>
<pre class="stan"><code>parameters {
  real x;
}
model {
  x ~ normal(mu, sigma);
}</code></pre>
<p>or equivalently</p>
<pre class="stan"><code>parameters {
  real&lt;location=0,scale=1&gt; x;
}
model {
  x ~ normal(mu, sigma);
}</code></pre>
</div>
<div id="expressions-as-bounds-and-locationscale" class="section level3 unnumbered">
<h3>Expressions as Bounds and Location/Scale</h3>
<p>Bounds (and location and scale)
for integer or real variables may be arbitrary expressions.
The only requirement is that they only include variables that have
been declared (though not necessarily defined) before the declaration.
If the bounds themselves are parameters, the behind-the-scenes
variable transform accounts for them in the log Jacobian.</p>
<p>For example, it is acceptable to have the
following declarations.</p>
<pre class="stan"><code>data {
 real lb;
}
parameters {
   real&lt;lower=lb&gt; phi;
}</code></pre>
<p>This declares a real-valued parameter <code>phi</code> to take values
greater than the value of the real-valued data variable <code>lb</code>.
Constraints may be complex expressions, but must be of type <code>int</code>
for integer variables and of type <code>real</code> for real variables
(including constraints on vectors, row vectors, and matrices).
Variables used in constraints can be any variable that has been
defined at the point the constraint is used. For instance,</p>
<pre class="stan"><code>data {
   int&lt;lower=1&gt; N;
   real y[N];
}
parameters {
   real&lt;lower=min(y), upper=max(y)&gt; phi;
}</code></pre>
<p>This declares a positive integer data variable <code>N</code>, an array
<code>y</code> of real-valued data of length <code>N</code>, and then a parameter
ranging between the minimum and maximum value of <code>y</code>. As shown
in the example code, the functions <code>min()</code> and <code>max()</code> may
be applied to containers such as arrays.</p>
<p>A more subtle case involves declarations of parameters or transformed
paramerrs based on parameters declared previously. For example, the
following program will work as intended.</p>
<pre><code>parameters {
  real a;
  real&lt;lower = a&gt; b;  // enforces a &lt; b
}
transformed parameters {
  real c;
  real&lt;lower = c&gt; d;
  c = a;
  d = b;
}</code></pre>
<p>The parameters instance works because all parameters are defined
externally before the block is executed. The transformed parameters
case works even though <code>c</code> isn’t defined at the point it is used,
because constraints on transformed parameters are only validated at
the end of the block. Data variables work like parameter variables,
whereas transformed data and generated quantity variables work like
transformed parameter variables.</p>
</div>
<div id="declaring-optional-variables" class="section level3 unnumbered">
<h3>Declaring Optional Variables</h3>
<p>A variable may be declared with a size that depends on a boolean
constant. For example, consider the definition of <code>alpha</code> in the
following program fragment.</p>
<pre class="stan"><code>data {
  int&lt;lower = 0, upper = 1&gt; include_alpha;
  ...
parameters {
  vector[include_alpha ? N : 0] alpha;</code></pre>
<p>If <code>include_alpha</code> is true, the model will include the vector
<code>alpha</code>; if the flag is false, the model will not include
<code>alpha</code> (technically, it will include <code>alpha</code> of size 0,
which means it won’t contain any values and won’t be included in any
output).</p>
<p>This technique is not just useful for containers. If the value of
<code>N</code> is set to 1, then the vector <code>alpha</code> will contain a
single element and thus <code>alpha[1]</code> behaves like an optional
scalar, the existence of which is controlled by <code>include_alpha</code>.</p>
<p>This coding pattern allows a single Stan program to define different
models based on the data provided as input. This strategy is used
extensively in the implementation of the RStanArm package (see
).</p>
</div>
</div>
<div id="vector-and-matrix-data-types" class="section level2">
<h2><span class="header-section-number">5.4</span> Vector and Matrix Data Types</h2>
<p>Stan provides three types of container objects: arrays, vectors, and
matrices. Vectors and matrices are more limited kinds of data
structures than arrays. Vectors are intrinsically one-dimensional
collections of reals, whereas matrices are intrinsically two
dimensional. Vectors, matrices, and arrays are not assignable to one
another, even if their dimensions are identical. A <span class="math inline">\(3 \times 4\)</span>
matrix is a different kind of object in Stan than a <span class="math inline">\(3 \times 4\)</span>
array.</p>
<p>The intention of using matrix types is to call out their usage in the
code. There are three situations in Stan where <em>only</em> vectors and
matrices may be used,</p>
<ul>
<li>matrix arithmetic operations (e.g., matrix multiplication)</li>
<li>linear algebra functions (e.g., eigenvalues and determinants),
and</li>
<li>multivariate function parameters and outcomes (e.g.,
multivariate normal distribution arguments).</li>
</ul>
<p>Vectors and matrices cannot be typed to return integer values. They
are restricted to <code>real</code> values.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<div id="indexing-from-1" class="section level3 unnumbered">
<h3>Indexing from 1</h3>
<p>Vectors and matrices, as well as arrays, are indexed starting from one
in Stan. This follows the convention in statistics and linear
algebra as well as their implementations in the statistical software
packages R, MATLAB, BUGS, and JAGS. General computer programming
languages, on the other hand, such as C++ and Python, index arrays
starting from zero.</p>
</div>
<div id="vectors" class="section level3 unnumbered">
<h3>Vectors</h3>
<p>Vectors in Stan are column vectors; see the next subsection for
information on row vectors. Vectors are declared with a size (i.e., a
dimensionality). For example, a 3-dimensional vector is declared with
the keyword <code>vector</code>, as follows.</p>
<pre class="stan"><code>vector[3] u;</code></pre>
<p>Vectors may also be declared with constraints, as in the following
declaration of a 3-vector of non-negative values.</p>
<pre class="stan"><code>vector&lt;lower=0&gt;[3] u;</code></pre>
<p>Similarly, they may be declared with a location and/or scale, as in the
following example</p>
<pre class="stan"><code>vector&lt;location=42,scale=3&gt;[3] u;</code></pre>
</div>
<div id="unit-simplexes" class="section level3 unnumbered">
<h3>Unit Simplexes</h3>
<p>A unit simplex is a vector with non-negative values whose entries sum
to 1. For instance, <span class="math inline">\([0.2,0.3,0.4,0.1]^{\top}\)</span> is a unit 4-simplex.
Unit simplexes are most often used as parameters in categorical
or multinomial distributions, and they are also the sampled variate in
a Dirichlet distribution. Simplexes are declared with their full
dimensionality. For instance, <code>theta</code> is declared to
be a unit <span class="math inline">\(5\)</span>-simplex by</p>
<pre class="stan"><code>simplex[5] theta;</code></pre>
<p>Unit simplexes are implemented as vectors and may be assigned to other
vectors and vice-versa. Simplex variables, like other constrained
variables, are validated to ensure they contain simplex values; for
simplexes, this is only done up to a statically specified accuracy
threshold <span class="math inline">\(\epsilon\)</span> to account for errors arising from floating-point
imprecision.</p>
<p>In high dimensional problems, simplexes may require smaller step sizes
in the inference algorithms in order to remain stable; this can be
achieved through higher target acceptance rates for samplers and
longer warmup periods, tighter tolerances for optimization with more
iterations, and in either case, with less dispersed parameter
initialization or custom initialization if there are informative
priors for some parameters.</p>
</div>
<div id="unit-vectors" class="section level3 unnumbered">
<h3>Unit Vectors</h3>
<p>A unit vector is a vector with a norm of one. For instance, <span class="math inline">\([0.5, 0.5, 0.5, 0.5]^{\top}\)</span> is a unit 4-vector. Unit vectors are sometimes
used in directional statistics. Unit vectors are declared with their
full dimensionality. For instance, <code>theta</code> is declared to be a unit
<span class="math inline">\(5\)</span>-vector by</p>
<pre class="stan"><code>unit_vector[5] theta;</code></pre>
<p>Unit vectors are implemented as vectors and may be assigned to other
vectors and vice-versa. Unit vector variables, like other constrained
variables, are validated to ensure that they are indeed unit length; for
unit vectors, this is only done up to a statically specified accuracy
threshold <span class="math inline">\(\epsilon\)</span> to account for errors arising from floating-point
imprecision.</p>
</div>
<div id="ordered-vectors" class="section level3 unnumbered">
<h3>Ordered Vectors</h3>
<p>An ordered vector type in Stan represents a vector whose entries are
sorted in ascending order. For instance, <span class="math inline">\((-1.3,2.7,2.71)^{\top}\)</span> is
an ordered 3-vector. Ordered vectors are most often employed as cut
points in ordered logistic regression models (see
<a href="#ordered-logistic.section">section</a>).</p>
<p>The variable <code>c</code> is declared as an ordered 5-vector by</p>
<pre class="stan"><code>ordered[5] c;</code></pre>
<p>After their declaration, ordered vectors, like unit simplexes, may be
assigned to other vectors and other vectors may be assigned to them.
Constraints will be checked after executing the block in which the
variables were declared.</p>
</div>
<div id="positive-ordered-vectors" class="section level3 unnumbered">
<h3>Positive, Ordered Vectors</h3>
<p>There is also a positive, ordered vector type which operates similarly
to ordered vectors, but all entries are constrained to be positive.
For instance, <span class="math inline">\((2,3.7,4,12.9)\)</span> is a positive, ordered 4-vector.</p>
<p>The variable <code>d</code> is declared as a positive, ordered 5-vector by</p>
<pre class="stan"><code>positive_ordered[5] d;</code></pre>
<p>Like ordered vectors, after their declaration, positive ordered vectors
may be assigned to other vectors and other vectors may be assigned to them.
Constraints will be checked after executing the block in which the
variables were declared.</p>
</div>
<div id="row-vectors" class="section level3 unnumbered">
<h3>Row Vectors</h3>
<p>Row vectors are declared with the keyword <code>row_vector</code>.
Like (column) vectors, they are declared with a size. For example,
a 1093-dimensional row vector <code>u</code> would be declared as</p>
<pre class="stan"><code>row_vector[1093] u;</code></pre>
<p>Constraints are declared as for vectors, as in the following example
of a 10-vector with values between -1 and 1.</p>
<pre class="stan"><code>row_vector&lt;lower=-1,upper=1&gt;[10] u;</code></pre>
<p>Location and scale are also similar as for the following 3-row-vector with
location -42 and scale 3.</p>
<pre class="stan"><code>row_vector&lt;location=-42,scale=3&gt;[3] u;</code></pre>
<p>Row vectors may not be assigned to column vectors, nor may column
vectors be assigned to row vectors. If assignments are required, they
may be accommodated through the transposition operator.</p>
</div>
<div id="matrices" class="section level3 unnumbered">
<h3>Matrices</h3>
<p>Matrices are declared with the keyword <code>matrix</code> along with a
number of rows and number of columns. For example,</p>
<pre class="stan"><code>matrix[3, 3] A;
matrix[M, N] B;</code></pre>
<p>declares <code>A</code> to be a <span class="math inline">\(3 \times 3\)</span> matrix and <code>B</code> to be a <span class="math inline">\(M \times N\)</span> matrix. For the second declaration to be well formed, the
variables <code>M</code> and <code>N</code> must be declared as integers in either
the data or transformed data block and before the matrix declaration.</p>
<p>Matrices may also be declared with constraints, as in this (<span class="math inline">\(3 \times 4\)</span>)
matrix of non-positive values.</p>
<pre class="stan"><code>matrix&lt;upper=0&gt;[3, 4] B;</code></pre>
<p>Similarly, matrices can be declared to have a set location and/or scale, as in
this matrix with scale 5.</p>
<pre class="stan"><code>matrix&lt;scale=5&gt;[3, 4] B;</code></pre>
<div id="assigning-to-rows-of-a-matrix" class="section level4 unnumbered">
<h4>Assigning to Rows of a Matrix</h4>
<p>Rows of a matrix can be assigned by indexing the left-hand side of an
assignment statement. For example, this is possible.</p>
<pre class="stan"><code>matrix[M, N] a;
row_vector[N] b;
// ...
a[1] = b;</code></pre>
<p>This copies the values from row vector <code>b</code> to <code>a[1]</code>, which
is the first row of the matrix <code>a</code>. If the number of columns in
<code>a</code> is not the same as the size of <code>b</code>, a run-time error is
raised; the number of columns of <code>a</code> is <code>N</code>, which is also the
number of columns of <code>b</code>.</p>
<p>Assignment works by copying values in Stan. That means any subsequent
assignment to <code>a[1]</code> does not affect <code>b</code>, nor does an
assignment to <code>b</code> affect <code>a</code>.</p>
</div>
</div>
<div id="covariance-matrices" class="section level3 unnumbered">
<h3>Covariance Matrices</h3>
<p>Matrix variables may be constrained to represent covariance matrices.
A matrix is a covariance matrix if it is symmetric and positive
definite. Like correlation matrices, covariance matrices only need a
single dimension in their declaration. For instance,</p>
<pre class="stan"><code>cov_matrix[K] Omega;</code></pre>
<p>declares <code>Omega</code> to be a <span class="math inline">\(K \times K\)</span> covariance matrix, where
<span class="math inline">\(K\)</span> is the value of the data variable <code>K</code>.</p>
</div>
<div id="correlation-matrices" class="section level3 unnumbered">
<h3>Correlation Matrices</h3>
<p>Matrix variables may be constrained to represent correlation matrices.
A matrix is a correlation matrix if it is symmetric and positive
definite, has entries between <span class="math inline">\(-1\)</span> and <span class="math inline">\(1\)</span>, and has a unit diagonal.
Because correlation matrices are square, only one dimension needs
to be declared. For example,</p>
<pre class="stan"><code>corr_matrix[3] Sigma;</code></pre>
<p>declares <code>Sigma</code> to be a <span class="math inline">\(3 \times 3\)</span> correlation matrix.</p>
<p>Correlation matrices may be assigned to other matrices, including
unconstrained matrices, if their dimensions match, and vice-versa.</p>
</div>
<div id="cholesky-factors-of-covariance-matrices" class="section level3 unnumbered">
<h3>Cholesky Factors of Covariance Matrices</h3>
<p>Matrix variables may be constrained to represent the Cholesky factors
of a covariance matrix. This is often more convenient or more
efficient than representing covariance matrices directly.</p>
<p>A Cholesky factor <span class="math inline">\(L\)</span> is an <span class="math inline">\(M \times N\)</span> lower-triangular matrix (if
<span class="math inline">\(m &lt; n\)</span> then <span class="math inline">\(L[m, n] =0\)</span>) with a strictly positive diagonal (<span class="math inline">\(L[k, k] &gt; 0\)</span>) and <span class="math inline">\(M \geq N\)</span>. If <span class="math inline">\(L\)</span> is a Cholesky factor, then <span class="math inline">\(\Sigma = L \, L^{\top}\)</span> is a covariance matrix (i.e., it is positive definite).
The mapping between positive definite matrixes and their Cholesky
factors is bijective—every covariance matrix has a unique Cholesky
factorization.</p>
<p>The typical case of a square Cholesky factor may be declared with a
single dimension,</p>
<pre class="stan"><code>cholesky_factor_cov[4] L;</code></pre>
<div id="cholesky-factors-of-positive-semi-definite-matrices" class="section level4 unnumbered">
<h4>Cholesky factors of positive semi-definite matrices</h4>
<p>In general, two dimensions may be declared, with the above being equal to
<code>cholesky_factor_cov[4, 4]</code>. The
type <code>cholesky_factor_cov[M, N]</code> may be used for the general
<span class="math inline">\(M \times N\)</span> case to produce positive semi-definite matrices of rank <span class="math inline">\(M\)</span>.</p>
</div>
</div>
<div id="cholesky-factors-of-correlation-matrices" class="section level3 unnumbered">
<h3>Cholesky Factors of Correlation Matrices</h3>
<p>Matrix variables may be constrained to represent the Cholesky factors
of a correlation matrix.</p>
<p>A Cholesky factor for a correlation matrix <span class="math inline">\(L\)</span> is a <span class="math inline">\(K \times K\)</span>
lower-triangular matrix with positive diagonal entries and rows that
are of length 1 (i.e., <span class="math inline">\(\sum_{n=1}^K L_{m,n}^2 = 1\)</span>). If <span class="math inline">\(L\)</span> is a
Cholesky factor for a correlation matrix, then <span class="math inline">\(L\,L^{\top}\)</span> is a
correlation matrix (i.e., symmetric positive definite with a unit
diagonal).</p>
<p>To declare the variable <code>L</code> to be a <code>K</code> by <code>K</code> Cholesky factor of a
correlation matrix, the following code may be used.</p>
<pre class="stan"><code>cholesky_factor_corr[K] L;</code></pre>
</div>
<div id="assigning-constrained-variables" class="section level3 unnumbered">
<h3>Assigning Constrained Variables</h3>
<p>Constrained variables of all types may be assigned to other variables
of the same unconstrained type and vice-versa. Matching is interpreted strictly
as having the same basic type and number of array dimensions.
Constraints are not considered, but basic data types are. For instance, a
variable declared to be <code>real&lt;lower=0,upper=1&gt;</code> could be assigned
to a variable declared as <code>real</code> and vice-versa. Similarly, a
variable declared as <code>matrix[3, 3]</code> may be assigned to a variable
declared as <code>cov_matrix[3]</code> or
<code>cholesky_factor_cov[3]</code>, and vice-versa.</p>
<p>Checks are carried out at the end of each relevant block of statements
to ensure constraints are enforced. This includes run-time size
checks. The Stan compiler isn’t able to catch the fact that an
attempt may be made to assign a matrix of one dimensionality to a
matrix of mismatching dimensionality.</p>
</div>
<div id="expressions-as-size-declarations" class="section level3 unnumbered">
<h3>Expressions as Size Declarations</h3>
<p>Variables may be declared with sizes given by expressions. Such
expressions are constrained to only contain data or transformed data
variables. This ensures that all sizes are determined once the data
is read in and transformed data variables defined by their statements.
For example, the following is legal.</p>
<pre class="stan"><code>data {
  int&lt;lower=0&gt; N_observed;    int&lt;lower=0&gt; N_missing;
  // ...
transformed parameters {
  vector[N_observed + N_missing] y;
  // ...</code></pre>
</div>
<div id="accessing-vector-and-matrix-elements" class="section level3 unnumbered">
<h3>Accessing Vector and Matrix Elements</h3>
<p>If <code>v</code> is a column vector or row vector, then <code>v[2]</code> is the
second element in the vector. If <code>m</code> is a matrix, then
<code>m[2, 3]</code> is the value in the second row and third column.</p>
<p>Providing a matrix with a single index returns the specified row. For
instance, if <code>m</code> is a matrix, then <code>m[2]</code> is the second row.
This allows Stan blocks such as</p>
<pre class="stan"><code>matrix[M, N] m;
row_vector[N] v;
real x;
// ...
v = m[2];
x = v[3];   // x == m[2][3] == m[2, 3]</code></pre>
<p>The type of <code>m[2]</code> is <code>row_vector</code> because it is the second
row of <code>m</code>. Thus it is possible to write <code>m[2][3]</code> instead
of <code>m[2, 3]</code> to access the third element in the second row. When
given a choice, the form <code>m[2, 3]</code> is preferred.</p>
<div id="array-index-style-array-index-style.footnote" class="section level4 unnumbered">
<h4>Array index style {#array-index-style.footnote}</h4>
<p>The form <code>m[2, 3]</code> is more efficient because it does not require the creation and use of an intermediate expression template for <code>m[2]</code>. In later versions, explicit calls to <code>m[2][3]</code> may be optimized to be as efficient as <code>m[2, 3]</code> by the Stan compiler.</p>
</div>
</div>
<div id="size-declaration-restrictions" class="section level3 unnumbered">
<h3>Size Declaration Restrictions</h3>
<p>An integer expression is used to pick out the sizes of vectors,
matrices, and arrays. For instance, we can declare a vector of size
<code>M + N</code> using</p>
<pre class="stan"><code>vector[M + N] y;</code></pre>
<p>Any integer-denoting expression may be used for the size declaration,
providing all variables involved are either data, transformed data, or
local variables. That is, expressions used for size declarations may
not include parameters or transformed parameters or generated
quantities.</p>
</div>
</div>
<div id="array-data-types.section" class="section level2">
<h2><span class="header-section-number">5.5</span> Array Data Types</h2>
<p>Stan supports arrays of arbitrary dimension. The values in an array
can be any type, so that arrays may contain values that are simple
reals or integers, vectors, matrices, or other arrays. Arrays are the
only way to store sequences of integers, and some functions in Stan,
such as discrete distributions, require integer arguments.</p>
<p>A two-dimensional array is just an array of arrays, both conceptually
and in terms of current implementation. When an index is supplied to
an array, it returns the value at that index. When more than one
index is supplied, this indexing operation is chained. For example, if
<code>a</code> is a two-dimensional array, then <code>a[m, n]</code> is just
a convenient shorthand for <code>a[m][n]</code>.</p>
<p>Vectors, matrices, and arrays are not assignable to one another, even
if their dimensions are identical.</p>
<div id="declaring-array-variables" class="section level3 unnumbered">
<h3>Declaring Array Variables</h3>
<p>Arrays are declared by enclosing the dimensions in square brackets
following the name of the variable.</p>
<p>The variable <code>n</code> is declared as an array of five integers as follows.</p>
<pre class="stan"><code>int n[5];</code></pre>
<p>A two-dimensional array of real values with three rows and four columns is
declared with the following.</p>
<pre class="stan"><code>real a[3, 4];</code></pre>
<p>A three-dimensional array <code>z</code> of positive reals with five rows, four
columns, and two shelves can be declared as follows.</p>
<pre class="stan"><code>real&lt;lower=0&gt; z[5, 4, 2];</code></pre>
<p>Arrays may also be declared to contain vectors. For example,</p>
<pre class="stan"><code>vector[7] mu[3];</code></pre>
<p>declares <code>mu</code> to be an array of size 3 containing vectors with 7
elements. Arrays may also contain matrices. The example</p>
<pre class="stan"><code>matrix[7, 2] mu[15, 12];</code></pre>
<p>declares a 15 by 12 array of <span class="math inline">\(7 \times 2\)</span> matrices. Any of the
constrained types may also be used in arrays, as in the declaration</p>
<pre class="stan"><code>cholesky_factor_cov[5, 6] mu[2, 3, 4];</code></pre>
<p>of a <span class="math inline">\(2 \times 3 \times 4\)</span> array of <span class="math inline">\(5 \times 6\)</span> Cholesky factors of
covariance matrices.</p>
</div>
<div id="accessing-array-elements-and-subarrays" class="section level3 unnumbered">
<h3>Accessing Array Elements and Subarrays</h3>
<p>If <code>x</code> is a 1-dimensional array of length 5, then <code>x[1]</code> is
the first element in the array and <code>x[5]</code> is the last. For a <span class="math inline">\(3 \times 4\)</span> array <code>y</code> of two dimensions, <code>y[1, 1]</code> is the first
element and <code>y[3, 4]</code> the last element. For a three-dimensional
array <code>z</code>, the first element is <code>z[1, 1, 1]</code>, and so on.</p>
<p>Subarrays of arrays may be accessed by providing fewer than the full
number of indexes. For example, suppose <code>y</code> is a two-dimensional
array with three rows and four columns. Then <code>y[3]</code> is
one-dimensional array of length four. This means that <code>y[3][1]</code>
may be used instead of <code>y[3, 1]</code> to access the value of the first
column of the third row of <code>y</code>. The form <code>y[3, 1]</code> is the
preferred form (see <a href="#array-index-style.section">note</a> in this chapter).</p>
</div>
<div id="assigning" class="section level3 unnumbered">
<h3>Assigning</h3>
<p>Subarrays may be manipulated and assigned just like any other
variables. Similar to the behavior of matrices, Stan allows blocks
such as</p>
<pre class="stan"><code>real w[9, 10, 11];
real x[10, 11];
real y[11];
real z;
// ...
x = w[5];
y = x[4];  // y == w[5][4] == w[5, 4]
z = y[3];  // z == w[5][4][3] == w[5, 4, 3]</code></pre>
</div>
<div id="arrays-of-matrices-and-vectors" class="section level3 unnumbered">
<h3>Arrays of Matrices and Vectors</h3>
<p>Arrays of vectors and matrices are accessed in the same way as arrays
of doubles. Consider the following vector and scalar declarations.</p>
<pre class="stan"><code>vector[5] a[3, 4];
vector[5] b[4];
vector[5] c;
real x;</code></pre>
<p>With these declarations, the following assignments are legal.</p>
<pre class="stan"><code>b = a[1];      // result is array of vectors
c = a[1, 3];    // result is vector
c = b[3];      //   same result as above
x = a[1, 3, 5];  // result is scalar
x = b[3, 5];    //   same result as above
x = c[5];      //   same result as above</code></pre>
<p>Row vectors and other derived vector types (simplex and ordered)
behave the same way in terms of indexing.</p>
<p>Consider the following matrix, vector and scalar declarations.</p>
<pre class="stan"><code>matrix[6, 5] d[3, 4];
matrix[6, 5] e[4];
matrix[6, 5] f;
row_vector[5] g;
real x;</code></pre>
<p>With these declarations, the following definitions are legal.</p>
<pre class="stan"><code>e = d[1];        // result is array of matrices
f = d[1,3];      // result is matrix
f = e[3];        //   same result as above
g = d[1,3,2];    // result is row vector
g = e[3,2];      //   same result as above
g = f[2];        //   same result as above
x = d[1,3,5,2];  // result is scalar
x = e[3,5,2];    //   same result as above
x = f[5,2];      //   same result as above
x = g[2];        //   same result as above</code></pre>
<p>As shown, the result <code>f[2]</code> of supplying a single index to a
matrix is the indexed row, here row 2 of matrix <code>f</code>.</p>
</div>
<div id="partial-array-assignment" class="section level3 unnumbered">
<h3>Partial Array Assignment</h3>
<p>Subarrays of arrays may be assigned by indexing on the left-hand side
of an assignment statement. For example, the following is legal.</p>
<pre class="stan"><code>real x[I,J,K];
real y[J,K];
real z[K];
// ...
x[1] = y;
x[1,1] = z;</code></pre>
<p>The sizes must match. Here, <code>x[1]</code> is a <code>J</code> by <code>K</code>
array, as is <code>y</code>.</p>
<p>Partial array assignment also works for arrays of matrices, vectors,
and row vectors.</p>
</div>
<div id="mixing-array-vector-and-matrix-types" class="section level3 unnumbered">
<h3>Mixing Array, Vector, and Matrix Types</h3>
<p>Arrays, row vectors, column vectors and matrices are not
interchangeable in Stan. Thus a variable of any one of these
fundamental types is not assignable to any of the others, nor may it
be used as an argument where the other is required (use as arguments
follows the assignment rules).</p>
<div id="mixing-vectors-and-arrays" class="section level4 unnumbered">
<h4>Mixing Vectors and Arrays</h4>
<p>For example, vectors cannot be assigned to arrays or vice-versa.</p>
<pre class="stan"><code>real a[4];
vector[4] b;
row_vector c[4];
// ...
a = b; // illegal assignment of vector to array
b = a; // illegal assignment of array to vector
a = c; // illegal assignment of row vector to array
c = a; // illegal assignment of array to row vector</code></pre>
</div>
<div id="mixing-row-and-column-vectors" class="section level4 unnumbered">
<h4>Mixing Row and Column Vectors</h4>
<p>It is not even legal to assign row vectors to column vectors or vice
versa.</p>
<pre class="stan"><code>vector b[4];
row_vector c[4];
// ...
b = c; // illegal assignment of row vector to column vector
c = b; // illegal assignment of column vector to row vector</code></pre>
</div>
<div id="mixing-matrices-and-arrays" class="section level4 unnumbered">
<h4>Mixing Matrices and Arrays</h4>
<p>The same holds for matrices, where 2-dimensional arrays may not be
assigned to matrices or vice-versa.</p>
<pre class="stan"><code>real a[3,4];
matrix[3,4] b;
// ...
a = b;  // illegal assignment of matrix to array
b = a;  // illegal assignment of array to matrix</code></pre>
</div>
<div id="mixing-matrices-and-vectors" class="section level4 unnumbered">
<h4>Mixing Matrices and Vectors</h4>
<p>A <span class="math inline">\(1 \times N\)</span> matrix cannot be assigned a row vector or
vice versa.</p>
<pre class="stan"><code>matrix[1,4] a;
row_vector[4] b;
// ...
a = b;  // illegal assignment of row vector to matrix
b = a;  // illegal assignment of matrix to row vector</code></pre>
<p>Similarly, an <span class="math inline">\(M \times 1\)</span> matrix may not be assigned to a column vector.</p>
<pre class="stan"><code>matrix[4,1] a;
vector[4] b;
// ...
a = b;  // illegal assignment of column vector to matrix
b = a;  // illegal assignment of matrix to column vector</code></pre>
</div>
</div>
<div id="size-declaration-restrictions-1" class="section level3 unnumbered">
<h3>Size Declaration Restrictions</h3>
<p>An integer expression is used to pick out the sizes of arrays. The
same restrictions as for vector and matrix sizes apply, namely that
the size is declared with an integer-denoting expression that does not
contain any parameters, transformed parameters, or generated quantities.</p>
</div>
<div id="size-zero-arrays" class="section level3 unnumbered">
<h3>Size Zero Arrays</h3>
<p>If any of an array’s dimensions is size zero, the entire array will be
of size zero. That is, if we declare</p>
<pre class="stan"><code>real a[3, 0];</code></pre>
<p>then the resulting size of <code>a</code> is zero and querying any of its
dimensions at run time will result in the value zero. Declared as
above, <code>a[1]</code> will be a size-zero one-dimensional array. For
comparison, declaring</p>
<pre class="stan"><code>real b[0, 3];</code></pre>
<p>also produces an array with an overall size of zero, but in this case,
there is no way to index legally into <code>b</code>, because <code>b[0]</code> is
undefined. The array will behave at run time as if it’s a <span class="math inline">\(0 \times 0\)</span> array. For example, the result of <code>to_matrix(b)</code> will be a
<span class="math inline">\(0 \times 0\)</span> matrix, not a <span class="math inline">\(0 \times 3\)</span> matrix.</p>
</div>
</div>
<div id="variable-types-vs.constraints-and-sizes" class="section level2">
<h2><span class="header-section-number">5.6</span> Variable Types vs.Constraints and Sizes</h2>
<p>The type information associated with a variable only contains the
underlying type and dimensionality of the variable.</p>
<div id="type-information-excludes-sizes" class="section level3 unnumbered">
<h3>Type Information Excludes Sizes</h3>
<p>The size associated with a given variable is not part of its data
type. For example, declaring a variable using</p>
<pre class="stan"><code>real a[3];</code></pre>
<p>declares the variable <code>a</code> to be an array. The fact that it was
declared to have size 3 is part of its declaration, but not part of
its underlying type.</p>
<div id="when-are-sizes-checked" class="section level4 unnumbered">
<h4>When are Sizes Checked?</h4>
<p>Sizes are determined dynamically (at run time) and thus cannot be
type-checked statically when the program is compiled. As a result,
any conformance error on size will raise a run-time error. For
example, trying to assign an array of size 5 to an array of size 6
will cause a run-time error. Similarly, multiplying an <span class="math inline">\(N \times M\)</span> by a <span class="math inline">\(J \times K\)</span> matrix will raise a run-time error if <span class="math inline">\(M \neq J\)</span>.</p>
</div>
</div>
<div id="type-information-excludes-constraints" class="section level3 unnumbered">
<h3>Type Information Excludes Constraints</h3>
<p>Like sizes, constraints are not treated as part of a variable’s type
in Stan when it comes to the compile-time check of operations it may
participate in. Anywhere Stan accepts a matrix as an argument, it
will syntactically accept a correlation matrix or covariance matrix or
Cholesky factor. Thus a covariance matrix may be assigned to a matrix
and vice-versa.</p>
<p>Similarly, a bounded real may be assigned to an unconstrained real and
vice-versa.</p>
<div id="when-are-function-argument-constraints-checked" class="section level4 unnumbered">
<h4>When are Function Argument Constraints Checked?</h4>
<p>For arguments to functions, constraints are sometimes, but not always
checked when the function is called. Exclusions include C++ standard
library functions. All probability functions and cumulative
distribution functions check that their arguments are appropriate at
run time as the function is called.</p>
</div>
<div id="when-are-declared-variable-constraints-checked" class="section level4 unnumbered">
<h4>When are Declared Variable Constraints Checked?</h4>
<p>For data variables, constraints are checked after the variable is read
from a data file or other source. For transformed data variables, the
check is done after the statements in the transformed data block have
executed. Thus it is legal for intermediate values of variables to
not satisfy declared constraints.</p>
<p>For parameters, constraints are enforced by the transform applied and
do not need to be checked. For transformed parameters, the check is
done after the statements in the transformed parameter block have
executed.</p>
<p>For all blocks defining variables (transformed data, transformed
parameters, generated quantities), real values are initialized to
<code>NaN</code> and integer values are initialized to the smallest legal
integer (i.e., a large absolute value negative number).</p>
<p>For generated quantities, constraints are enforced after the
statements in the generated quantities block have executed.</p>
</div>
</div>
<div id="type-naming-notation" class="section level3 unnumbered">
<h3>Type Naming Notation</h3>
<p>In order to refer to data types, it is convenient to have a way to
refer to them. The type naming notation outlined in this section is
not part of the Stan programming language, but rather a convention
adopted in this document to enable a concise description of a type.</p>
<p>Because size information is not part of a data type, data types will
be written without size information. For instance, <code>real[]</code> is the
type of one-dimensional array of reals and <code>matrix</code> is the type of
matrices. The three-dimensional integer array type is written as
<code>int[ , ,]</code>, indicating the number slots available for indexing.
Similarly, <code>vector[ , ]</code> is the type of a two-dimensional array of
vectors.</p>
</div>
</div>
<div id="compound-variable-declaration-and-definition" class="section level2">
<h2><span class="header-section-number">5.7</span> Compound Variable Declaration and Definition</h2>
<p>Stan allows assignable variables to be declared and defined in a
single statement. Assignable variables are</p>
<ul>
<li>local variables, and</li>
<li>variables declared in the transformed data,
transformed parameters, or generated quantities blocks.</li>
</ul>
<p>For example, the statement</p>
<pre class="stan"><code>int N = 5;</code></pre>
<p>declares the variable <code>N</code> to be an integer scalar type and at the
same time defines it to be the value of the expression <code>5</code>.</p>
<div id="assignment-typing" class="section level3 unnumbered">
<h3>Assignment Typing</h3>
<p>The type of the expression on the right-hand side of the assignment
must be assignable to the type of the variable being declared. For
example, it is legal to have</p>
<pre class="stan"><code>real sum = 0;</code></pre>
<p>even though <code>0</code> is of type <code>int</code> and <code>sum</code> is of type <code>real</code>, because
integer-typed scalar expressions can be assigned to real-valued scalar
variables. In all other cases, the type of the expression on the
right-hand side of the assignment must be identical to the type of the
variable being declared.</p>
<p>Any type may be assigned. For example,</p>
<pre class="stan"><code>matrix[3, 2] a = b;</code></pre>
<p>declares a matrix variable <code>a</code> and assigns it to the value of <code>b</code>,
which must be of type <code>matrix</code> for the compound statement to be well
formed. The sizes of matrices are not part of their static typing and
cannot be validated until run time.</p>
</div>
<div id="right-hand-side-expressions" class="section level3 unnumbered">
<h3>Right-Hand Side Expressions</h3>
<p>The right-hand side may be any expression which has a type which is
assignable to the variable being declared. For example,</p>
<pre class="stan"><code>matrix[3, 2] a = 0.5 * (b + c);</code></pre>
<p>assigns the matrix variable <code>a</code> to half of the sum of <code>b</code> and <code>c</code>.
The only requirement on <code>b</code> and <code>c</code> is that the expression <code>b + c</code> be
of type <code>matrix</code>. For example, <code>b</code> could be of type <code>matrix</code> and <code>c</code>
of type <code>real</code>, because adding a matrix to a scalar produces a matrix,
and the multiplying by a scalar produces another matrix.</p>
<p>The right-hand side expression can be a call to a user defined
function, allowing general algorithms to be applied that might not be
otherwise expressible as simple expressions (e.g., iterative or
recursive algorithms).</p>
</div>
<div id="scope-within-expressions" class="section level3 unnumbered">
<h3>Scope within Expressions</h3>
<p>Any variable that is in scope and any function that is available in
the block in which the compound declaration and definition appears may
be used in the expression on the right-hand side of the compound
declaration and definition statement.</p>

</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="1">
<li id="fn1"><p>Stan compiles integers to <code>int</code> and reals to <code>double</code> types in C++. Precise details of rounding will depend on the compiler and hardware architecture on which the code is run.<a href="data-types-chapter.html#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>This may change if Stan is called upon to do complicated integer matrix operations or boolean matrix operations. Integers are not appropriate inputs for linear algebra functions.<a href="data-types-chapter.html#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="whitespace.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="expressions.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": null,
"fontsettings": {
"theme": "white",
"family": "serif",
"size": 2
},
"edit": null,
"download": null,
"toc": {
"collapse": "section",
"scroll_highlight": true
},
"search": false,
"toolbar": {
"position": "static"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
